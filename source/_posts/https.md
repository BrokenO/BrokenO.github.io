---
title: https 加密解密以及验证与签名
tags:
  - 网络传输
  - ssl/tls
categories:
  - HTTP
  - HTTPS
toc: false
date: 2019-03-08 10:55:21
---

### 老规矩，https是什么？

**网络之所以要分层主要是因为网络的不确定性**

http是明文传输，通信不安全

https 在网络分层模型中并不是一个单独的分层

https只是在http与tcp之间添加了一个TLS或者SSL的中间件用于保证通信安全


Https的安全保证基于 **对称加密，非对称加密以及验证验证与签名。**

### 对称加密

通信双方拥有相同的密钥。发送方用密钥加密，接收方用相同的密钥解密 称之为 对称加密

```
优点：算法公开、计算量小、加密速度快、加密效率高

缺点：密钥不好传输，（https使用的是传递参数，双方通过一定的规则生成密钥）
```
<!-- more -->

相关的算法 ： 

```	
AES : 密钥的长度可以为128、192、256位，也就是16个字节、24个字节、32个字节

DES：密钥的长度64位，8个字节，由于密码太短，已经被启用
```

### 非对称加密

通信双方均拥有各自的公钥与私钥，发送方使用 **接收方的公钥** 加密，接收方接收到数据后用**自己的私钥解密**。接收方使用发送方的公钥加密，发送方使用自己的私钥解密，称之为非对称加密。

简称 **公钥加密，私钥解密**

优点： 公钥传输方便安全

缺点：算法复杂，加密速度慢

相关的算法：RSA DSA（比特币使用该算法，只用于数字签名） ，ECC（椭圆曲线算法）


### 验证与签名

验证的目的是为了证明 **信息的发送方**，签名的目的是为了 **验证发送的信息是否被篡改**

用私钥加密，用公钥解密称之为 验证。

信息通过一定的hash算法生成摘要，然后用私钥加密 生成签名，然后将签名与hash算法附加在信息之后一起发送，接收方接收到数据之后用hash算法对信息进行hash，然后用发送方的公钥解密，对量两个的hash值。如果用公钥能解密，则说明信息来自与发送方，如果hash值一致则表示消息没有被篡改

![image.png](/images/2019/03/08/7e0a4a60-4155-11e9-a650-ffecf938c9ad.png)

### 数字证书

数字证书包含了由受信任的机构担保的用户或公司的相关信息

数字证书中的内容有：证书的发布者，证书发布者的数字签名，用户或公司的 公钥，用户或公司的主机名

### https（TLS/SSL）的连接过程

1.A 向 B发送连接请求，会附加一个加密套件（cipersuite）以及一个随机数 X，其中加密套件中包含了对称加密算法，非对称加密算法，以及hash算法

2.B接收到A的请求后会在cipersuite中选择对应的加密算法与非加密算法以及hash算法回传给B，同时也会附加一个随机数 Y

3.同时B会回传自己的数字证书（用于对方获取自己的公钥）

4.A收到B的回传之后，使用权威机构提供的公钥，验证证书是否为该机构颁发，再验证该证书的主机名是否与自己通信的主机名一致，最后过验证签名机制验证签名是否被更改，由此可以拿到B的公钥。

5.拿到B的公钥之后A会再生成一个随机数 Z

6.使用B的公钥将该随机数加密之后发送给B

7.此时AB双方已经拥有了相同的随机数 X,Y,Z，加密算法，以及hash算法

8.双方按照约定通过 `DH` 算法生成密钥

9.双方通过加密后的密钥进行通信

### [DH（Diffie-Hellman）](DH（Diffie-Hellman）)密钥交换算法

DH算法的原理基于离散对数的难题 如下所示：
![image.png](/images/2019/03/08/3c7aa570-4184-11e9-a650-ffecf938c9ad.png)

解释一下
1. 通信甲、乙双方分别拥有两个相同的大数 P,G
2. 甲生成随机数 a, 通过算法 Ka = P<sup>a</sup> mod G 等到数 Ka
3. 乙同样生成随机数b，通过算法 Kb = P<sup>b</sup> mod G 等到数 Kb
4. 甲乙双方通过 **非对称算法** 将 Ka 与 Kb 传递给对方
5. 此时甲拥有的数为 ：P,G,a，kb；乙拥有的数为：P,G,b，ka
6. 甲通过 **Kb<sup>a</sup> mod G = K1** 生成密钥K1，乙通过 **Ka<sup>b</sup> mod G = K2** 生成K2，如果是通信双方，那么此时 K1 = K2
7. 就算有黑客获取到了数 P,G，以及Ka,Kb,但是当它们都是非常大的数的时候，依靠这四个数来计算a和b非常困难，**这就是离散对数数学难题**。 

### 最后我来梳理以下https底层生成密钥的流程


1. 甲向乙发送一个tcp请求（明文） ，明文中附带了一个随机数 **P** 以及 **加密套件（cipersuit）**，加密套件中包含了对称加密算法，非对称加密算法以及hash算法

2. 乙收到之后选择对应的加密套件（对称加密算法，非对称加密算法以及hash算法），同时返回一个大随机数 **G**，此时甲乙共同拥有相同的随机数 **P、G** 以及加密套件。

3. 乙会附带返回自己的数字证书给乙。

4. 甲对乙的数字证书验证通过之后，会随机生成一个随机数 **a** ,通过 **DH** 算法生成随机数 **Ka**，然后通过双方选定的非对称加密算法将 **Ka** 发送给 乙。（此时已经建立了连接是密文了）

5. 乙收到甲的随机数之后，乙也会生成一个随机数 **b**，也通过 **DH** 算法生成随机数 **Kb**，然后乙也同样会通过非对称加密将Kb发送给甲。

6. 这一步结束之后 甲中拥有了 随机数 **P、G、a、Kb**，乙拥有了随机数：**P、G、b、Ka**

7. 甲通过 **Kb<sup>a</sup> mod G = K1** 生成密钥K1，乙通过 **Ka<sup>b</sup> mod G = K2** 生成K2 **（DH算法）**

8. 如果K1 == K2，那么表示通信的是甲乙双方。

9. 甲乙通过密钥 K1 与 K2 互相通信。

最后来张图镇楼
![image.png](/images/2019/03/08/e026e3b0-418d-11e9-a650-ffecf938c9ad.png)
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘鹏(BrokenO)</title>
  
  <subtitle>Stay hungry, Stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-19T05:22:04.208Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>（BrokenO)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Intent的匹配规则</title>
    <link href="http://yoursite.com/2020/04/19/Intent%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2020/04/19/Intent的匹配规则/</id>
    <published>2020-04-19T01:41:09.000Z</published>
    <updated>2020-04-19T05:22:04.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Intent的作用范围"><a href="#Intent的作用范围" class="headerlink" title="Intent的作用范围"></a>Intent的作用范围</h3><p>Intent是用于除ContentProvider的其他三大组件（Activity，Service，BroadcastReceiver）</p><p>android应用安装之后，系统会读取其相应的manifest.xml清单文件，会将其中的组件一一归类保存，<strong>每一个组件中可以包含0个1个或者多个 Intent-Filter</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当应用需要启动除ContentProvider之外的三大组件时，如果Intent中没有设置对应组件的类名（全路径），</span><br><span class="line">则系统会通过Intent-filter的匹配来查找对应的具体组件。如果设置了对应组件的类名，</span><br><span class="line">则即便在manifest文件中存在Intent-filter，系统也不再进行Intent-filter的匹配去寻找对应的组件。</span><br><span class="line"></span><br><span class="line">简单来说就是，如果指定了对象，直接启动，没指定对象，遍历所有的组件，寻找合适的启动。</span><br></pre></td></tr></table></figure></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intent-filter匹配的结果可以是一个，可以是多个，也可能一个也没有。</span><br></pre></td></tr></table></figure><h3 id="Intent的组成"><a href="#Intent的组成" class="headerlink" title="Intent的组成"></a>Intent的组成</h3><p><img src="/images/2020/04/19/e5ae7ba0-81e6-11ea-92f8-ab273354db60.png" alt="image.png"></p><h5 id="Intent-filter与组件（activity等）的关系："><a href="#Intent-filter与组件（activity等）的关系：" class="headerlink" title="Intent-filter与组件（activity等）的关系："></a>Intent-filter与组件（activity等）的关系：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.在manifest.xml中一个组件（Activity等）中可以包含多个intent-filter标签,只要有一个intent-filter标签匹配，即表示匹配成功</span><br><span class="line"></span><br><span class="line">2.一个intent-filter标签中可以包含多个category，多个action</span><br></pre></td></tr></table></figure><p><strong>Category，action，data三个共同影响intent-filter的匹配结果，只有三项完全匹配才算匹配成功</strong>，其中任意一个匹配失败，则当前intent-filter匹配失败</p><h3 id="Category的匹配规则"><a href="#Category的匹配规则" class="headerlink" title="Category的匹配规则"></a>Category的匹配规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.如果intent中包含了category选项，则必须与intent-filter中完全匹配，才算匹配成功。</span><br><span class="line"></span><br><span class="line">2.如果intent中不包含category选项，则系统会在intent中添加一个默认的**android.intent.category.DEFAULT选项，</span><br><span class="line">这也是想要隐式启动的组件的intent-filter中必须要添加category为android.intent.category.DEFAULT选项的原因。</span><br><span class="line"></span><br><span class="line">3.上面说了一个intent-filter中可以包含多个category，则只要intent中的category是intent-filter中的子集（即被包含于intent-filter）</span><br><span class="line">既可以通过category匹配</span><br></pre></td></tr></table></figure><h3 id="Action的匹配规则"><a href="#Action的匹配规则" class="headerlink" title="Action的匹配规则"></a>Action的匹配规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.隐式启动的intent中必须包含action，否则匹配不能成功</span><br><span class="line"></span><br><span class="line">2.如果包含action，则action必须完全匹配成功方能成功，注意：匹配区分大小写</span><br><span class="line"></span><br><span class="line">3.上面提到intent-filter中可以有多个action，只要intent中的action是intent-filter中action的子集，即可通过匹配。</span><br></pre></td></tr></table></figure><h3 id="Data的匹配规则"><a href="#Data的匹配规则" class="headerlink" title="Data的匹配规则"></a>Data的匹配规则</h3><p>intent中的data由 MIME Type 与URI组成</p><p>data的匹配与其他两项不同，前面两项都强调intent中的值必须是intent-filter中的子集，<strong>而data只有intent-filter中存在data标签，<br>才需要去匹配intent中的data字段</strong>，比如filter中指定了mimeType则只需要匹配intent中mimeType类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不扯那些没用的，就一句话，intent-filter中data有啥 intent就匹配啥，没有的直接匹配成功</span><br><span class="line"></span><br><span class="line">如果intent-filter中的 MIME Type不为空，而intent中的为空，但是URI不为空，且通过URI能推断出MIME Type则一样能通过匹配</span><br></pre></td></tr></table></figure><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>Extra是通过一个bundle报保存键值对数据，由于bundle实现了parcelable接口，能实现序列化可以做到跨进程传输</p><h3 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h3><p>该处的flags主要用于组件的启动标志，与组件的启动模式有关，具体看下一篇：Activity的启动模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Intent的作用范围&quot;&gt;&lt;a href=&quot;#Intent的作用范围&quot; class=&quot;headerlink&quot; title=&quot;Intent的作用范围&quot;&gt;&lt;/a&gt;Intent的作用范围&lt;/h3&gt;&lt;p&gt;Intent是用于除ContentProvider的其他三大组件（A
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>序列化</title>
    <link href="http://yoursite.com/2019/10/26/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2019/10/26/序列化/</id>
    <published>2019-10-26T08:05:36.000Z</published>
    <updated>2019-11-05T04:34:23.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大纲："><a href="#大纲：" class="headerlink" title="大纲："></a>大纲：</h3><ul><li>序列化是什么</li><li>序列化解决了什么问题</li><li>序列化的具体实现</li><li>序列化代理的意图与实现</li><li>序列化要注意的点</li><li>android中使用的序列化方式</li><li>序列化的使用 深克隆</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>将对象编码成一个字节流称之为 <strong>序列化</strong></p><p>从字节流中重新构建对象称之为 <strong>反序列化</strong></p><p>有一种更直接的说法，序列化其实就是给写入字节流中的每一个对象 <strong>进行编号</strong>，而反序列化就是根据对象的编号找到相应对象的引用<br><a id="more"></a></p><h4 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><p><img src="/images/2019/10/26/6d598780-f7c6-11e9-b976-4793a243304d.png" alt="image.png"><br>输入与输出是相对的，一般从内存的角度来看：</p><p>1.从文件写入内存，为<strong>输入流（InputStream）</strong>,是将二进制流转换为对象的运行时数据结构,对应的是 <strong>反序列化</strong> 的过程，输入流对应的是<strong>read</strong>方法</p><p>2.从内存写入文件，为<strong>输出流（OutputStream）</strong>,是将对象转换为二进制流，该过程对应的是 <strong>序列化</strong> 的过程，输出流对应的是<strong>write</strong>方法</p><p>其实输入输出流与序列化与反序列化没有直接联系，这里联系在一起是为了方便记忆</p><h3 id="序列化的作用"><a href="#序列化的作用" class="headerlink" title="序列化的作用"></a><strong>序列化的作用</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.持久化 序列化很大一部分原因是为了进行持久化操作</span><br><span class="line"></span><br><span class="line">2.传输 例如跨进程传输，远程传输（RMI）</span><br></pre></td></tr></table></figure><h3 id="序列化的实现"><a href="#序列化的实现" class="headerlink" title="序列化的实现"></a>序列化的实现</h3><p>对象需要实现序列化，必须要实现 <strong>Serializable</strong> 接口,如果该对象的成员变量是引用类型则该成员变量，也需要实现 <strong>Serializable</strong> 接口，否则序列化会失败</p><p>下面是标准的序列化与反序列化的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">             ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos)) &#123;</span><br><span class="line">            oos.writeObject(obj);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">            ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            Object o = ois.readObject();</span><br><span class="line"></span><br><span class="line">            ois.close();</span><br><span class="line">            bis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>序列化的实现分为使用<strong>默认的序列化方式与自定义的序列化方式</strong></p><h4 id="标准的序列化"><a href="#标准的序列化" class="headerlink" title="标准的序列化"></a>标准的序列化</h4><p>标准的序列化流程比较简单：</p><p>1.写入对象的类型信息</p><p>2.写入对象成员变量的 <strong>类型信息</strong> 以及 <strong>变量名</strong> 并编号，类型信息包含<strong>serialVersionUID</strong></p><p>3.如果成员变量是引用类型或数组，则需要写入数组与类在虚拟机中的表现类型</p><p>4.写入对象的值，由于前面已经将类型的引用全部编号，后续可以直接引用</p><p>5.如果是基本类型（除数组与引用类型）直接写入String</p><p>6.如果是已经类型，则需要递归前面的操作</p><h4 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h4><p>之所以会有自定义的序列化，原因有以下几个：</p><p>1.安全校验 对于安全性要求比较严格的数据一般需要通过比较严格的数据校验才使用</p><p>2.独立控制序列化与反序列化的流程，方便定制</p><p>readObject方法  readObject方法相当于类的另一个共有的构造器，构造器必须要做参数合法性校验，并在有必要时对参数进行保护性拷贝</p><p>writeObject方法 如果类中存在该方法，则对象的序列化只会执行该方法而放弃默认的序列化方式，所以如果仅仅是只做参数的安全性校验还需要调用默认的序列化方法</p><p>readResolve方法 在单例模式下，如果当前单例类实现了序列化接口，那么该单例就有可能在反序列化时跳过构造函数，而产生不同的对象，所以有必要在readResolve方法中将返回值手动指向创建的全局单例对象</p><h4 id="序列化代理"><a href="#序列化代理" class="headerlink" title="序列化代理"></a>序列化代理</h4><p>序列化代理是目前认为比较好的对象序列化的方法，原因是通过序列化代理可以控制对象的创建一定需要经过构造函数，从而能在构造函数中对参数进行控制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.start.compareTo(<span class="keyword">this</span>.end) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(start + <span class="string">" after "</span> + end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getStart</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Date(start.getTime());&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getEnd</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Date(end.getTime());&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Interval&#123;"</span> + <span class="string">"start="</span> + start + <span class="string">", end="</span> + end + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serivalVersionUID = <span class="number">213214124141L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line"></span><br><span class="line">        SerializationProxy(Interval interval) &#123;</span><br><span class="line">            <span class="keyword">this</span>.start = interval.start;</span><br><span class="line">            <span class="keyword">this</span>.end = interval.end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SerializationProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的存在导致序列化系统产生一个SerializationProxy实例，代替外围类的实例，也就是说，writeReplace方法在序列化之前，将外围类的实例转变成了它的序列化代理。这样序列化系统就永远不会产生外围类的序列化实例，但是攻击者可能伪造，企图违反该类的约束条件，为了应付这个，我们只需向前面所做的一样，在Interval类里添加一个readObject方法，它禁止了反序列化外围类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> InvalidObjectException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Proxy required!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，我们只要在SerializationProxy类添加一个readResolve方法，它返回一个逻辑上相当的外围类的实例，它可以让序列化系统在反序列化的时候将序列化代理转变回外围类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interval(start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个readResolve方法仅仅利用了外围类的公有构造器创建了外围类的一个实例，它极大的消除了序列化机制中语言本身之外的特征，因为反序列实例是利用与任何其他实例相同的构造器，静态工厂和方法创建的，和直接创建的实例没有什么区别，这样你就不必单独确保反序列化的实例一定要遵守类的约束条件了。<br>　　正如保护性拷贝一样，序列化代理方法可以阻止伪字节流攻击和内部域盗用攻击，而且这种方法允许Interval的域为final，这种方法也也使我们省了不少麻烦，你不必知道哪些域可能受到狡猾的序列化攻击的威胁，你也不必显示地执行有效检查，作为反序列化的一部分。</p><h4 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h4><p>如果对象的成员变量被transient关键字修饰，那么在序列化与反序列化的过程中会忽略该字段</p><h4 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h4><p>如果一个类实现了Serializable接口，那么请尽量提供serialVersionUID的值，目前这个值有两种提供方式，一个是使用默认的值，一种是编译器提供一个随机数。</p><p>如果没有提供UID字段，那么系统在序列化与反序列化会通过一系列的散列算法计算出一个对应的值，如果当前的类在序列化之后发生了改变，那么两个类在反序列化时由于生成的UID对应不上会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**如果当前类实现了Serializable接口，为了避免在后面类的迭代过程中反序列化出错，请显示提供serialVersionUID字段**</span><br></pre></td></tr></table></figure><h4 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h4><p>由于通过序列化与反序列化产生的是完全不同的对象，所以可以用来做对象的深克隆，但是深克隆构建对象比复制或者克隆数据域的方法要慢很多</p><p>实现代码在上面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个对象被同时序列化两次，即便后一次对当前对象的属性作了修改，在序列化时由于当前的对象已经存在，所以存在序列化流中的只是当前对象的一个引用，反序列化出来的是同一个对象。</span><br></pre></td></tr></table></figure><h4 id="android中的序列化方式-parelable"><a href="#android中的序列化方式-parelable" class="headerlink" title="android中的序列化方式 parelable"></a>android中的序列化方式 parelable</h4><p>1.serializable一般用于数据的持久化，使用I/O读写存储于硬盘<br>2.parcelable直接在内存中读写，速度要比serializable快很多<br>3.serializable会使用到反射，而反射是很耗性能的操作<br>4.arcelable是自己实现封送与解封，过程中不涉及反射等耗性能操作，数据也存储在Native内存中，效率比serializable要高很多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">综上：serializable实现简单，性能消耗大，效率低，内存占用大。 parcelable实现相对复杂，但是内存占用率较低，且没有反射等耗性能操作，效率极高。在android等移动设备中应该优先使用parcelable</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;大纲：&quot;&gt;&lt;a href=&quot;#大纲：&quot; class=&quot;headerlink&quot; title=&quot;大纲：&quot;&gt;&lt;/a&gt;大纲：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;序列化是什么&lt;/li&gt;
&lt;li&gt;序列化解决了什么问题&lt;/li&gt;
&lt;li&gt;序列化的具体实现&lt;/li&gt;
&lt;li&gt;序列化代理的意图与实现&lt;/li&gt;
&lt;li&gt;序列化要注意的点&lt;/li&gt;
&lt;li&gt;android中使用的序列化方式&lt;/li&gt;
&lt;li&gt;序列化的使用 深克隆&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;将对象编码成一个字节流称之为 &lt;strong&gt;序列化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从字节流中重新构建对象称之为 &lt;strong&gt;反序列化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一种更直接的说法，序列化其实就是给写入字节流中的每一个对象 &lt;strong&gt;进行编号&lt;/strong&gt;，而反序列化就是根据对象的编号找到相应对象的引用&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>单例模式详解</title>
    <link href="http://yoursite.com/2019/03/10/singleton-pattern/"/>
    <id>http://yoursite.com/2019/03/10/singleton-pattern/</id>
    <published>2019-03-10T14:53:48.000Z</published>
    <updated>2019-11-05T04:26:24.526Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>1.单例模式的设计意图是什么？它要解决一个什么问题？什么时候可以使用它？</p><p>2.它是如何解决问题的？</p><p>3.结构图是怎样的，有哪些关键代码</p><p>4.能够想到这个设计模式的两个应用实例，一个生活中，一个软件中</p><p>5.这个模式的优缺点是什么？在使用时要注意什么</p><a id="more"></a><h3 id="单例模式的设计意图"><a href="#单例模式的设计意图" class="headerlink" title="单例模式的设计意图"></a>单例模式的设计意图</h3><p>单例模式设计的意图是 为了节约系统资源，确保当前的类在进程的生命周期中只会存在一个实例，也就是说当前类的构造方法在进程的生命周期中只会被调用一次。</p><p>如果有些类占用资源太多，或者如果有多个实例会难于管理，比方说线程池，数据库连接池之类的，这些需要使用到单例模式</p><h3 id="单例模式是如何解决问题的？"><a href="#单例模式是如何解决问题的？" class="headerlink" title="单例模式是如何解决问题的？"></a>单例模式是如何解决问题的？</h3><p>因为在进程中只存在唯一的一个实例，所以在任意时刻通过该类拿到的永远是同一个对象，实现了资源的复用</p><h3 id="单例模式的实现与结构图"><a href="#单例模式的实现与结构图" class="headerlink" title="单例模式的实现与结构图"></a>单例模式的实现与结构图</h3><p>目前实现单例模式的方式著有要三种 ：<strong>静态内部类（推荐），枚举（一般），双重检查锁 DCL（一般）</strong></p><h3 id="要实现单例要做的几件事"><a href="#要实现单例要做的几件事" class="headerlink" title="要实现单例要做的几件事"></a>要实现单例要做的几件事</h3><ol><li><p>构造器必需私有化，也就是说外部不能调用到自己的构造方法</p></li><li><p>拥有一个全局的私有静态变量</p></li><li><p>提供一个访问该私有变量的静态方法</p></li></ol><h3 id="静态内部类的实现方式"><a href="#静态内部类的实现方式" class="headerlink" title="静态内部类的实现方式"></a>静态内部类的实现方式</h3><p>静态内部类实现单例的原理是 利用 JVM 的 <strong>类加载机制实现的</strong>。类加载时会在<strong>初始化阶段</strong>为所有的静态变量赋值。</p><p>其典型的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleHodler</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  xxx  instance = <span class="keyword">new</span> xxx();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> xxx&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingleHodler.instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举没啥好说的，其实现原理与静态内部类一样</p><p>但是枚举要注意一个反序列化生成对象的问题，通过序列化可以将一个对象写入到磁盘，然后要使用的时候通过反序列化可以得到一个新的对象，这就有可能使得单例模式失效。</p><p>反序列化提供了一个很特别的钩子函数，类中具有一个私有的被实例化的方法 <code>readResolve</code> ,我们可以通过控制该方法控制对象的反序列化，要杜绝反序列化生成新对象可以实现如下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;<span class="comment">//返回自己创建的单例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法是底层通过反射调用的</p><h3 id="双重检查锁（double-ckeck-lock）"><a href="#双重检查锁（double-ckeck-lock）" class="headerlink" title="双重检查锁（double ckeck lock）"></a>双重检查锁（double ckeck lock）</h3><p>双重检查锁的目的是为了解决<strong>多线程下单例</strong>的问题。<strong>其使用的volatile关键字在JDK1.5以后才有，并且volatile的禁止指令重排机制会屏蔽虚拟机的一些优化操作，因此并不是单例的一种完美实现方式。</strong></p><p><strong>如果static变量不添加volatile关键字是有可能导致单例失效的</strong>，其具体原因如下：</p><p>一个对象的创建过程由这么几步组成，1.分配内存 2.初始化 3.将instance对象指向分配的内存空间。那么由于JVM允许在执行时进行指令优化，如果不添加volatile关键字，那么2与3的执行顺序是不确定的，有可能是1-2-3，也有可能是1-3-2.如果是1-3-2，3先执行，2未执行，如果此时切换线程B，此时instance在线程A中已经执行过3了，所以instance不为空，线程B会直接取走instance，在使用的时候就会报错，这就是DCL失效的问题</p><h3 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h3><p>优点：</p><ol><li><p>提供了唯一对象的受控访问，可以严格控制用户的访问</p></li><li><p>由于内存中只存在一个对象，节约了系统资源</p></li></ol><p>缺点：</p><ol><li><p>由于单例模式中没有抽象层，所以扩展会很困难</p></li><li><p>单例类的职责过重，在一定程度上违反了单一职责原则</p></li><li><p>在很多面向对象语言中都提供了垃圾自动回收机制，如果实例共享对象长时间没有被引用，会被收集器回收，再次使用时会重新创建对象，此时有可能会导致共享对象的状态丢失</p></li></ol><p>目前推荐使用的是静态内部类与枚举</p><p><strong>为了防止反射与反序列化重新创建对象由如下解决方式：如果是反射，可以在构造函数中判断当前实例是否存在，如果已经存在则抛出异常，反序列化前面已经讲过了不再重复。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h3&gt;&lt;p&gt;1.单例模式的设计意图是什么？它要解决一个什么问题？什么时候可以使用它？&lt;/p&gt;
&lt;p&gt;2.它是如何解决问题的？&lt;/p&gt;
&lt;p&gt;3.结构图是怎样的，有哪些关键代码&lt;/p&gt;
&lt;p&gt;4.能够想到这个设计模式的两个应用实例，一个生活中，一个软件中&lt;/p&gt;
&lt;p&gt;5.这个模式的优缺点是什么？在使用时要注意什么&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面向对象程序设计原则</title>
    <link href="http://yoursite.com/2019/03/10/design-principles/"/>
    <id>http://yoursite.com/2019/03/10/design-principles/</id>
    <published>2019-03-10T08:54:27.000Z</published>
    <updated>2019-10-24T06:05:38.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解一个设计模式要掌握的要点："><a href="#理解一个设计模式要掌握的要点：" class="headerlink" title="理解一个设计模式要掌握的要点："></a>理解一个设计模式要掌握的要点：</h3><p></p><p class="div-blue"><br>1.这个设计模式的意图是什么？它要解决一个什么问题？什么时候可以使用它？</p><p>2.它是如何解决问题的？掌握它的结构图，记住关键代码</p><p>3.能够想到这个设计模式的两个应用实例，一个生活中，一个软件中</p><p>4.这个模式的优缺点是什么？在使用时要注意什么</p><p>5.多运用，多实践，多运用，多实践，多运用，多实践（重要的问题说三遍！！！）<br></p><br><a id="more"></a><p></p><h3 id="实际应用中共有三类共24中设计模式如图所示："><a href="#实际应用中共有三类共24中设计模式如图所示：" class="headerlink" title="实际应用中共有三类共24中设计模式如图所示："></a>实际应用中共有三类共24中设计模式如图所示：</h3><p><img src="/images/2019/03/10/05f71b20-4317-11e9-9d1e-f5f058a63503.png" alt="image.png"></p><p><img src="/images/2019/03/10/fb708e70-4316-11e9-9d1e-f5f058a63503.png" alt="image.png"></p><p>创建型：单例模式，简单工厂模式，工厂方法模式，抽象工厂模式，原型模式，创建者模式（6种）</p><p>结构型：适配器，桥接，组合，装饰，外观，享元，代理（7种）</p><p>行为型：访问者，策略，观察者，责任链，命令，解释器，迭代器，中介者，备忘录，状态，模板（11种）</p><h3 id="单一职责原则-（SRP）"><a href="#单一职责原则-（SRP）" class="headerlink" title="单一职责原则 （SRP）"></a>单一职责原则 （SRP）</h3><p>定义：一个类只负责一个功能领域中的相应职责，或者说，就一个类而言，应该只有一个引起它变化的原因</p><p><strong>单一职责原则是实现高类聚，低耦合的指导方针，一个类承载的职责越多，可复用性就越低</strong></p><h3 id="开闭原则-（OCP）"><a href="#开闭原则-（OCP）" class="headerlink" title="开闭原则 （OCP）"></a>开闭原则 （OCP）</h3><p>定义：<strong>一个软件实体应该对扩展开放，对修改关闭。即软件应该在不修改现有的代码的情况下进行扩展</strong></p><p><strong>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键</strong></p><p>开闭原则是所有设计模式优缺点的一个评价要点，并以此判断系统是否具备有良好的灵活性与扩展性</p><h3 id="里氏替换原则-（LSP）"><a href="#里氏替换原则-（LSP）" class="headerlink" title="里氏替换原则 （LSP）"></a>里氏替换原则 （LSP）</h3><p>定义：所有引用基类（父类）的地方必须能透明的使用其子类对象。也就是说在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><p><strong>在运用里氏替换原则时，应将父类设计为抽象类或者接口，让子类继承或实现父类接口，并实现再父类中声明的方法，可以很方便的扩展功能，无需修改现有子类的代码，增加新的功能可以通过增加一个新的子类实现</strong></p><h3 id="依赖倒转原则-（DIP）"><a href="#依赖倒转原则-（DIP）" class="headerlink" title="依赖倒转原则 （DIP）"></a>依赖倒转原则 （DIP）</h3><p>定义：抽象不应该依赖与细节，细节应该依赖于抽象。换句话说就是：要针对接口编程，而不是针对实现编程</p><p>依赖倒置的原则要求在代码中传递参数或在关联关系中，<strong>尽量使用层次高的抽象层类，即使用接口与抽象类进行变量声明，参数类型声明以及方法返回类型声明，以及数据类型的转换，而不要使用具体类来做这些事情。</strong>一个具体的类应该只实现抽象类或者接口中的方法，否则无法调用到在子类中声明的方法。</p><p>比方说： A能读txt文件，B能读 pdf文件，调用方需要接收读文件的结果。其设计模式应为：调用方需要的只是一份文件，不管时TXT还是pdf，所以要引入一个读文件的抽象，其中有一个read方法，而A跟B实现这个抽象</p><p>在实现依赖倒转原则时需要针对抽象层进行编程，而将具体类的对象通过<strong>依赖注入</strong>的方式注入到其他对象中。<strong>依赖注入是指当一个对象要与其他对象发生关系时，通过抽象来注入所依赖的对象。</strong><br>常用的注入有三种方式：<strong>构造注入，设置注入（setter）和接口注入</strong></p><p><strong>在一般情况下，依赖注入，里氏替换与开闭原则会同时出现，开闭原则是目标，里氏替换是基础，依赖注入是手段。</strong></p><h3 id="接口隔离原则-（ISP）"><a href="#接口隔离原则-（ISP）" class="headerlink" title="接口隔离原则 （ISP）"></a>接口隔离原则 （ISP）</h3><p>定义：使用多个专门的接口，而不是使用单一的总接口，即客户端不应该依赖那些它不需要的接口</p><p>当一个接口太大时，可以将其分割为一些更小的接口，每一个接口应当承担相对独立的角色。</p><p>原则就是，给你想要的，你不想要的坚决不给。</p><h3 id="合成复用原则-（CARP）"><a href="#合成复用原则-（CARP）" class="headerlink" title="合成复用原则 （CARP）"></a>合成复用原则 （CARP）</h3><p>定义：<strong>尽量使用对象组合，而不是使用继承来达到复用的目的</strong>。</p><h3 id="迪米特法则：（CRP）"><a href="#迪米特法则：（CRP）" class="headerlink" title="迪米特法则：（CRP）"></a>迪米特法则：（CRP）</h3><p>定义：一个软件实体 应当尽可能的少于其他实体发生相互作用</p><p>当一个模块发生修改时，应当尽量少的影响到其他模块，扩展相对会容易</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;理解一个设计模式要掌握的要点：&quot;&gt;&lt;a href=&quot;#理解一个设计模式要掌握的要点：&quot; class=&quot;headerlink&quot; title=&quot;理解一个设计模式要掌握的要点：&quot;&gt;&lt;/a&gt;理解一个设计模式要掌握的要点：&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p class=&quot;div-blue&quot;&gt;&lt;br&gt;1.这个设计模式的意图是什么？它要解决一个什么问题？什么时候可以使用它？&lt;/p&gt;
&lt;p&gt;2.它是如何解决问题的？掌握它的结构图，记住关键代码&lt;/p&gt;
&lt;p&gt;3.能够想到这个设计模式的两个应用实例，一个生活中，一个软件中&lt;/p&gt;
&lt;p&gt;4.这个模式的优缺点是什么？在使用时要注意什么&lt;/p&gt;
&lt;p&gt;5.多运用，多实践，多运用，多实践，多运用，多实践（重要的问题说三遍！！！）&lt;br&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>okhttp3 的工作原理与源码分析</title>
    <link href="http://yoursite.com/2019/03/08/okhttp/"/>
    <id>http://yoursite.com/2019/03/08/okhttp/</id>
    <published>2019-03-08T06:08:49.000Z</published>
    <updated>2019-11-05T04:26:44.827Z</updated>
    
    <content type="html"><![CDATA[<p>OkHttpClient 应该被设计为一个单例，以便复用连接池与线程池，避免造成资源不必要的资源浪费</p><h3 id="okhttp-的连接池设计"><a href="#okhttp-的连接池设计" class="headerlink" title="okhttp 的连接池设计"></a>okhttp 的连接池设计</h3><p>为了避免在请求同一个连接时在重新建立连接上产生的时延，Okhttp设计了socket连接 复用机制。</p><ol><li><p>每次有新的请求到来时，会先去连接池中查找当前请求的连接是否已经存在。</p></li><li><p>如果连接存在（连接相同的标准是：），直接复用。</p></li><li><p>如果不存在，则重新创建一个连接，然后将连接放进连接池,在放进连接池时会通过<code>线程池</code>对连接池进行清理与维护，用来释放已经<code>空闲超时</code>的连接.</p></li></ol><a id="more"></a><h4 id="okhttp-的连接池的清理逻辑"><a href="#okhttp-的连接池的清理逻辑" class="headerlink" title="okhttp 的连接池的清理逻辑"></a>okhttp 的连接池的清理逻辑</h4><p> 直接上源码</p><ol><li><p>如果连接池中不存在当前请求的连接，则先判断当前连接池是否在执行清理操作，如果没有先执行连接池清理操作。然后将新的请求添加到连接池中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123; <span class="comment">//如果不是是在清理中，则执行清理操作</span></span><br><span class="line">      cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">      executor.execute(cleanupRunnable); <span class="comment">//有线程池管理，执行清理操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    connections.add(connection);<span class="comment">//添加连接到线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行清理操作，这里要注意两点：如果清理返回的结果为 -1，那么表示连接池中没有连接，那么清理线程也就没有一直循环下去的必要了。如果在清理的过程中发现有空闲连接，但是空闲连接没有达到超时时间，那么当前执行清理的线程会休眠（时间为达到超时的时间），如果在此休眠期间没有重新调用该连接，那么超时时间之后会执行清理操作。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());<span class="comment">//执行清理操作 返回需要等待的时间</span></span><br><span class="line">        <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">//如果返回-1表示连接池为空跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123; <span class="comment">//如果等待超时的时间大于0，那么当前线程会清理休眠等待时间</span></span><br><span class="line">          <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">          waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>3.清理操作主要由cleanup执行，clean的时候分以下几个步骤：</p><pre><code>1.首先先找到连接池中空闲时间最长的连接，以及空闲连接数2.其次判断当前空闲连接数如果大于默认的连接数，则直接移除当前的空闲连接，关闭连接sokect3.如果当前空闲时间大于默认的空闲时间，也直接移除当前的空闲连接，关闭连接sokect4.如果当前连接池中存在空闲连接，那么直接返回超时时间差，返回之后，当前线程会休眠当前这个时间差，然后继续下一次清理5.如果没有空闲线程，直接返回默认的超时时间，当前清理线程会休眠6.如果没有连接，则当前清理线程会退出。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>; <span class="comment">//正在使用中连接的个数</span></span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>; <span class="comment">//空闲连接的个数</span></span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>; <span class="comment">//空闲时间最长的连接</span></span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE; <span class="comment">//最长的空闲时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the connection is in use, keep searching.</span></span><br><span class="line">        <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;<span class="comment">//如果当前线程在使用</span></span><br><span class="line">          inUseConnectionCount++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idleConnectionCount++; <span class="comment">//走到这里表示已经发现了空闲连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the connection is ready to be evicted, we're done.</span></span><br><span class="line">        <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//循环到此处会得到空闲时间最长的连接</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs <span class="comment">//如果空闲时间大于默认的时间 5分钟</span></span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;<span class="comment">//空闲连接数大于最大空闲数 5个</span></span><br><span class="line">        <span class="comment">// We've found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class="line">        <span class="comment">// of the synchronized block).</span></span><br><span class="line">        connections.remove(longestIdleConnection);<span class="comment">//直接将该连接移出连接池</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;<span class="comment">//如果空闲的个数大于0</span></span><br><span class="line">        <span class="comment">// A connection will be ready to evict soon.</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs; <span class="comment">//返回下次清理还需等待的时间</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123; <span class="comment">//如果使用的连接数大于0 直接返回默认的超时时间</span></span><br><span class="line">        <span class="comment">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果没有连接，清理线程将退出执行</span></span><br><span class="line">        <span class="comment">// No connections, idle or in use.</span></span><br><span class="line">        cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closeQuietly(longestIdleConnection.socket()); <span class="comment">//关闭当前的连接socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup again immediately.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>来一张连接池的流程图：<strong>（为什么是5，默认超时时间是 5分钟，空闲链接为5，可以自定义）</strong><br><img src="/images/2019/03/09/749ee470-4283-11e9-a1b6-4f48496f0a49.png" alt="image.png"><br><img src="/images/2019/03/09/7c841250-4283-11e9-a1b6-4f48496f0a49.png" alt="image.png"></p><h3 id="okhttp-的Cache设计"><a href="#okhttp-的Cache设计" class="headerlink" title="okhttp 的Cache设计"></a>okhttp 的Cache设计</h3><p id="div-blue"><br>数据结构：private final Deque<realconnection> connections = new ArrayDeque&lt;&gt;();<br></realconnection></p><br><p id="div-blue">完美的邂逅，这个纯属扯淡</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OkHttpClient 应该被设计为一个单例，以便复用连接池与线程池，避免造成资源不必要的资源浪费&lt;/p&gt;
&lt;h3 id=&quot;okhttp-的连接池设计&quot;&gt;&lt;a href=&quot;#okhttp-的连接池设计&quot; class=&quot;headerlink&quot; title=&quot;okhttp 的连接池设计&quot;&gt;&lt;/a&gt;okhttp 的连接池设计&lt;/h3&gt;&lt;p&gt;为了避免在请求同一个连接时在重新建立连接上产生的时延，Okhttp设计了socket连接 复用机制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;每次有新的请求到来时，会先去连接池中查找当前请求的连接是否已经存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果连接存在（连接相同的标准是：），直接复用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果不存在，则重新创建一个连接，然后将连接放进连接池,在放进连接池时会通过&lt;code&gt;线程池&lt;/code&gt;对连接池进行清理与维护，用来释放已经&lt;code&gt;空闲超时&lt;/code&gt;的连接.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>https 加密解密以及验证与签名</title>
    <link href="http://yoursite.com/2019/03/08/https/"/>
    <id>http://yoursite.com/2019/03/08/https/</id>
    <published>2019-03-08T02:55:21.000Z</published>
    <updated>2019-10-24T06:03:23.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="老规矩，https是什么？"><a href="#老规矩，https是什么？" class="headerlink" title="老规矩，https是什么？"></a>老规矩，https是什么？</h3><p><strong>网络之所以要分层主要是因为网络的不确定性</strong></p><p>http是明文传输，通信不安全</p><p>https 在网络分层模型中并不是一个单独的分层</p><p>https只是在http与tcp之间添加了一个TLS或者SSL的中间件用于保证通信安全</p><p>Https的安全保证基于 <strong>对称加密，非对称加密以及验证验证与签名。</strong></p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>通信双方拥有相同的密钥。发送方用密钥加密，接收方用相同的密钥解密 称之为 对称加密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：算法公开、计算量小、加密速度快、加密效率高</span><br><span class="line"></span><br><span class="line">缺点：密钥不好传输，（https使用的是传递参数，双方通过一定的规则生成密钥）</span><br></pre></td></tr></table></figure><a id="more"></a><p>相关的算法 ： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AES : 密钥的长度可以为128、192、256位，也就是16个字节、24个字节、32个字节</span><br><span class="line"></span><br><span class="line">DES：密钥的长度64位，8个字节，由于密码太短，已经被启用</span><br></pre></td></tr></table></figure><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>通信双方均拥有各自的公钥与私钥，发送方使用 <strong>接收方的公钥</strong> 加密，接收方接收到数据后用<strong>自己的私钥解密</strong>。接收方使用发送方的公钥加密，发送方使用自己的私钥解密，称之为非对称加密。</p><p>简称 <strong>公钥加密，私钥解密</strong></p><p>优点： 公钥传输方便安全</p><p>缺点：算法复杂，加密速度慢</p><p>相关的算法：RSA DSA（比特币使用该算法，只用于数字签名） ，ECC（椭圆曲线算法）</p><h3 id="验证与签名"><a href="#验证与签名" class="headerlink" title="验证与签名"></a>验证与签名</h3><p>验证的目的是为了证明 <strong>信息的发送方</strong>，签名的目的是为了 <strong>验证发送的信息是否被篡改</strong></p><p>用私钥加密，用公钥解密称之为 验证。</p><p>信息通过一定的hash算法生成摘要，然后用私钥加密 生成签名，然后将签名与hash算法附加在信息之后一起发送，接收方接收到数据之后用hash算法对信息进行hash，然后用发送方的公钥解密，对量两个的hash值。如果用公钥能解密，则说明信息来自与发送方，如果hash值一致则表示消息没有被篡改</p><p><img src="/images/2019/03/08/7e0a4a60-4155-11e9-a650-ffecf938c9ad.png" alt="image.png"></p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书包含了由受信任的机构担保的用户或公司的相关信息</p><p>数字证书中的内容有：证书的发布者，证书发布者的数字签名，用户或公司的 公钥，用户或公司的主机名</p><h3 id="https（TLS-SSL）的连接过程"><a href="#https（TLS-SSL）的连接过程" class="headerlink" title="https（TLS/SSL）的连接过程"></a>https（TLS/SSL）的连接过程</h3><p>1.A 向 B发送连接请求，会附加一个加密套件（cipersuite）以及一个随机数 X，其中加密套件中包含了对称加密算法，非对称加密算法，以及hash算法</p><p>2.B接收到A的请求后会在cipersuite中选择对应的加密算法与非加密算法以及hash算法回传给B，同时也会附加一个随机数 Y</p><p>3.同时B会回传自己的数字证书（用于对方获取自己的公钥）</p><p>4.A收到B的回传之后，使用权威机构提供的公钥，验证证书是否为该机构颁发，再验证该证书的主机名是否与自己通信的主机名一致，最后过验证签名机制验证签名是否被更改，由此可以拿到B的公钥。</p><p>5.拿到B的公钥之后A会再生成一个随机数 Z</p><p>6.使用B的公钥将该随机数加密之后发送给B</p><p>7.此时AB双方已经拥有了相同的随机数 X,Y,Z，加密算法，以及hash算法</p><p>8.双方按照约定通过 <code>DH</code> 算法生成密钥</p><p>9.双方通过加密后的密钥进行通信</p><h3 id="DH（Diffie-Hellman）密钥交换算法"><a href="#DH（Diffie-Hellman）密钥交换算法" class="headerlink" title="DH（Diffie-Hellman）密钥交换算法"></a><a href="DH（Diffie-Hellman）">DH（Diffie-Hellman）</a>密钥交换算法</h3><p>DH算法的原理基于离散对数的难题 如下所示：<br><img src="/images/2019/03/08/3c7aa570-4184-11e9-a650-ffecf938c9ad.png" alt="image.png"></p><p>解释一下</p><ol><li>通信甲、乙双方分别拥有两个相同的大数 P,G</li><li>甲生成随机数 a, 通过算法 Ka = P<sup>a</sup> mod G 等到数 Ka</li><li>乙同样生成随机数b，通过算法 Kb = P<sup>b</sup> mod G 等到数 Kb</li><li>甲乙双方通过 <strong>非对称算法</strong> 将 Ka 与 Kb 传递给对方</li><li>此时甲拥有的数为 ：P,G,a，kb；乙拥有的数为：P,G,b，ka</li><li>甲通过 <strong>Kb<sup>a</sup> mod G = K1</strong> 生成密钥K1，乙通过 <strong>Ka<sup>b</sup> mod G = K2</strong> 生成K2，如果是通信双方，那么此时 K1 = K2</li><li>就算有黑客获取到了数 P,G，以及Ka,Kb,但是当它们都是非常大的数的时候，依靠这四个数来计算a和b非常困难，<strong>这就是离散对数数学难题</strong>。 </li></ol><h3 id="最后我来梳理以下https底层生成密钥的流程"><a href="#最后我来梳理以下https底层生成密钥的流程" class="headerlink" title="最后我来梳理以下https底层生成密钥的流程"></a>最后我来梳理以下https底层生成密钥的流程</h3><ol><li><p>甲向乙发送一个tcp请求（明文） ，明文中附带了一个随机数 <strong>P</strong> 以及 <strong>加密套件（cipersuit）</strong>，加密套件中包含了对称加密算法，非对称加密算法以及hash算法</p></li><li><p>乙收到之后选择对应的加密套件（对称加密算法，非对称加密算法以及hash算法），同时返回一个大随机数 <strong>G</strong>，此时甲乙共同拥有相同的随机数 <strong>P、G</strong> 以及加密套件。</p></li><li><p>乙会附带返回自己的数字证书给乙。</p></li><li><p>甲对乙的数字证书验证通过之后，会随机生成一个随机数 <strong>a</strong> ,通过 <strong>DH</strong> 算法生成随机数 <strong>Ka</strong>，然后通过双方选定的非对称加密算法将 <strong>Ka</strong> 发送给 乙。（此时已经建立了连接是密文了）</p></li><li><p>乙收到甲的随机数之后，乙也会生成一个随机数 <strong>b</strong>，也通过 <strong>DH</strong> 算法生成随机数 <strong>Kb</strong>，然后乙也同样会通过非对称加密将Kb发送给甲。</p></li><li><p>这一步结束之后 甲中拥有了 随机数 <strong>P、G、a、Kb</strong>，乙拥有了随机数：<strong>P、G、b、Ka</strong></p></li><li><p>甲通过 <strong>Kb<sup>a</sup> mod G = K1</strong> 生成密钥K1，乙通过 <strong>Ka<sup>b</sup> mod G = K2</strong> 生成K2 <strong>（DH算法）</strong></p></li><li><p>如果K1 == K2，那么表示通信的是甲乙双方。</p></li><li><p>甲乙通过密钥 K1 与 K2 互相通信。</p></li></ol><p>最后来张图镇楼<br><img src="/images/2019/03/08/e026e3b0-418d-11e9-a650-ffecf938c9ad.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;老规矩，https是什么？&quot;&gt;&lt;a href=&quot;#老规矩，https是什么？&quot; class=&quot;headerlink&quot; title=&quot;老规矩，https是什么？&quot;&gt;&lt;/a&gt;老规矩，https是什么？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;网络之所以要分层主要是因为网络的不确定性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http是明文传输，通信不安全&lt;/p&gt;
&lt;p&gt;https 在网络分层模型中并不是一个单独的分层&lt;/p&gt;
&lt;p&gt;https只是在http与tcp之间添加了一个TLS或者SSL的中间件用于保证通信安全&lt;/p&gt;
&lt;p&gt;Https的安全保证基于 &lt;strong&gt;对称加密，非对称加密以及验证验证与签名。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h3&gt;&lt;p&gt;通信双方拥有相同的密钥。发送方用密钥加密，接收方用相同的密钥解密 称之为 对称加密&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;优点：算法公开、计算量小、加密速度快、加密效率高&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;缺点：密钥不好传输，（https使用的是传递参数，双方通过一定的规则生成密钥）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
      <category term="HTTPS" scheme="http://yoursite.com/categories/HTTP/HTTPS/"/>
    
    
      <category term="网络传输" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"/>
    
      <category term="ssl/tls" scheme="http://yoursite.com/tags/ssl-tls/"/>
    
  </entry>
  
  <entry>
    <title>http的思维逻辑</title>
    <link href="http://yoursite.com/2019/03/07/http/"/>
    <id>http://yoursite.com/2019/03/07/http/</id>
    <published>2019-03-07T13:36:57.000Z</published>
    <updated>2019-10-23T03:07:30.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本文的主要意义在于通过逻辑的分析与概括，弄清楚以下几个问题"><a href="#本文的主要意义在于通过逻辑的分析与概括，弄清楚以下几个问题" class="headerlink" title="本文的主要意义在于通过逻辑的分析与概括，弄清楚以下几个问题:"></a>本文的主要意义在于通过逻辑的分析与概括，弄清楚以下几个问题:</h3><ol><li>http 是什么</li><li>http 的作用是什么</li><li>http 的主要结构是什么</li><li>tcp 的工作机制与原理</li><li>http在Android中的具体实现</li></ol><h3 id="首先我们来聊聊http是什么？"><a href="#首先我们来聊聊http是什么？" class="headerlink" title="首先我们来聊聊http是什么？"></a>首先我们来聊聊http是什么？</h3><h4 id="学过计算机的人都知道，http是基于C-S架构的-应用层-网络通信协议"><a href="#学过计算机的人都知道，http是基于C-S架构的-应用层-网络通信协议" class="headerlink" title="学过计算机的人都知道，http是基于C/S架构的 应用层 网络通信协议"></a>学过计算机的人都知道，http是基于C/S架构的 应用层 网络通信协议</h4><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这句话中有很多隐含的信息：</span><br><span class="line"></span><br><span class="line">第一个，既然是 通信协议 ，那么就肯定有协议规范。</span><br><span class="line"></span><br><span class="line">第二个，既然是基于C/S架构，那么就必然有请求端与服务端</span><br><span class="line"></span><br><span class="line">第三个，既然是高层应用层框架，那么肯定就会有底层的支持，**http底层依赖可靠传输的TCP协议**</span><br><span class="line"></span><br><span class="line">第四个，http是可靠的协议</span><br></pre></td></tr></table></figure><p><strong>来个总结：</strong> http定义了通信双方的通信规范报文格式，即 <strong>请求格式</strong> 与  <strong>响应格式</strong>，基于C/S架构使得通信结构相对稳定，<strong>底层的实现依赖于TCP协议</strong></p><p>所以http是 <strong>一个稳定可靠的应用层协议</strong></p><h4 id="来看看http协议的传输报文格式"><a href="#来看看http协议的传输报文格式" class="headerlink" title="来看看http协议的传输报文格式"></a>来看看http协议的传输报文格式</h4><p><strong>请求报文：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">起始行：  请求方法  url  协议及版本  例如：GET  /v.gif  http/<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">首部： host / key : value 的形式保存例如：content-length ： <span class="number">15000</span> / content-type ： image/gif等等</span><br><span class="line"></span><br><span class="line">请求体：  body（有些方法请求是不能由body的 如get/head）</span><br></pre></td></tr></table></figure><p><strong>响应报文：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">起始行：  协议版本 状态码  当前状态信息  例如：HTTP/<span class="number">1.0</span>  <span class="number">200</span>  OK</span><br><span class="line"></span><br><span class="line">首部： key : value 的形式保存例如：content-length ： <span class="number">15000</span> / content-type ： image/gif等等</span><br><span class="line"></span><br><span class="line">响应体：  body（包含请求返回的主体内容）</span><br></pre></td></tr></table></figure><p><strong>请求方法</strong>主要是有以下几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.GET ：http定义的安全方法，使用该方法不会对服务器上产生什么影响，大部分用于读取服务器数据   没有body</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.POST : 主要用于提交表单数据到服务器，服务器要对此作出反应（需要严格验证）有body</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.HEAD : http定义的安全方法，与GET方法有点类似，但这种请求的响应只会返回首部 可用于对资源进行检查  没有body</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.DELETE : 请求服务器删除指定的资源（需要严格验证） 有body</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.PUT : 向服务器写入资源（需要严格验证）  有body</span><br></pre></td></tr></table></figure><p><strong>GET与PUT方法是幂等的，也就是说你PUT 一次与PUT十次结果是一样的并不会有所区别</strong></p><p><strong>响应状态码</strong>主要有以下一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.100</span>~<span class="number">199</span>：说明收到请求的初始部分，请客户端继续 《信息类型状态码》</span><br><span class="line"></span><br><span class="line"><span class="number">2.200</span>~<span class="number">299</span> : <span class="number">200</span> OK 请求成功  <span class="number">201</span> Create 用于创建服务器对象成功 等等  《成功类型状态码》</span><br><span class="line"></span><br><span class="line"><span class="number">3.300</span>~<span class="number">399</span> : 表示请求的资源已经改变，需要去新的地址获取 《重定向状态码》</span><br><span class="line"></span><br><span class="line"><span class="number">4.400</span>~<span class="number">499</span> : <span class="number">401</span> 未授权  <span class="number">404</span> 找不到资源 等等《客户端错误状态码》</span><br><span class="line"></span><br><span class="line"><span class="number">5.500</span>~<span class="number">599</span> : <span class="number">500</span>  <span class="number">502</span> Bad Gateway《服务端错误状态码》</span><br></pre></td></tr></table></figure><p><code>一个http请求主要包括协议 URL 以及端口，http默认的端口是80，其中URL对应机器的IP地址，端口则对应机器上的应用程序</code></p><h3 id="http底层用的是TCP，那么TCP又是什么？"><a href="#http底层用的是TCP，那么TCP又是什么？" class="headerlink" title="http底层用的是TCP，那么TCP又是什么？"></a>http底层用的是TCP，那么TCP又是什么？</h3><ol><li><p>TCP是一个传输层协议，为<strong>http提供了一条可靠的比特传输管道</strong>，从tcp一端写入的字节会从另一端以原有的顺序正确的传送出来</p></li><li><p>TCP流是分段传输的，由网络层的IP分组传输。TCP收到数据流之后会将其砍成被称作段的一小块然后加上自己的首部（端口号）往下传递给IP层</p></li><li><p>TCP在接收到一个包之后，会对当前包的顺序进行确认，如果后面再有相同的包传过来会直接丢弃掉。</p></li><li><p>由于是分段传输的，在网络不稳定的情况下，TCP需要对接收到的包进行 <strong>排序</strong> 与 <strong>去重</strong> 以及进行 <strong>丢包重传</strong>。    </p></li></ol><h4 id="我们来看看TCP连接的真实过程"><a href="#我们来看看TCP连接的真实过程" class="headerlink" title="我们来看看TCP连接的真实过程"></a>我们来看看TCP连接的真实过程</h4><p>1.客户端要跟服务端建立连接，那么客户端会向服务端发送一个小的IP分组，并再这个分组中附加上一个<strong>SYNC</strong>的标志信息，表示想要连接服务器</p><p>2.如果服务端接受了连接，就会会连接参数进行计算，也生成一个SYNC的标志，并且对客户端的SYNC进行回应，发送一个ACK = SYNC + 1 的值，表示自己已经接受了连接</p><p>3.客户端接收到之后，再往服务器发送一个分组，且附加一个ACK = SYNC + 1的标志位，服务端接收到之后连接建立。</p><h4 id="为什么连接需要三次握手？"><a href="#为什么连接需要三次握手？" class="headerlink" title="为什么连接需要三次握手？"></a>为什么连接需要三次握手？</h4><p>三次握手的原则设计是<strong>防止旧复用链接的初始化</strong>导致问题，为了解决此问题，我们设计了<strong>reset</strong>这个特别的控制信号来处理。如果接收中的 TCP 在一个未同步状态如 SYN-SENT, SYN-RECEIVED，它会返回 reset 给对方。如果 TCP 是同步状态中如(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT)，他会终止此连接并通知用户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TCP A                                                TCP B</span><br><span class="line">​</span><br><span class="line">  <span class="number">1</span>.  CLOSED                                               LISTEN</span><br><span class="line">​</span><br><span class="line">  <span class="number">2</span>.  SYN-SENT    --&gt; &lt;SEQ=<span class="number">100</span>&gt;&lt;CTL=SYN&gt;               ...</span><br><span class="line">​</span><br><span class="line">  <span class="number">3</span>.  (duplicate) ... &lt;SEQ=<span class="number">90</span>&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED</span><br><span class="line">​</span><br><span class="line">  <span class="number">4</span>.  SYN-SENT    &lt;-- &lt;SEQ=<span class="number">300</span>&gt;&lt;ACK=<span class="number">91</span>&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED</span><br><span class="line">​</span><br><span class="line">  <span class="number">5</span>.  SYN-SENT    --&gt; &lt;SEQ=<span class="number">91</span>&gt;&lt;CTL=RST&gt;               --&gt; LISTEN</span><br><span class="line">  </span><br><span class="line">​</span><br><span class="line">  <span class="number">6</span>.              ... &lt;SEQ=<span class="number">100</span>&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED</span><br><span class="line">​</span><br><span class="line">  <span class="number">7</span>.  SYN-SENT    &lt;-- &lt;SEQ=<span class="number">400</span>&gt;&lt;ACK=<span class="number">101</span>&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED</span><br><span class="line">​</span><br><span class="line">  <span class="number">8</span>.  ESTABLISHED --&gt; &lt;SEQ=<span class="number">101</span>&gt;&lt;ACK=<span class="number">401</span>&gt;&lt;CTL=ACK&gt;      --&gt; ESTABLISHED</span><br><span class="line">​</span><br><span class="line">                    Recovery from Old Duplicate SYN</span><br></pre></td></tr></table></figure><p>这是 复用连接时，旧在途包发往新连接中的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>中，一个旧的重复的 SYN到达 B。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>中， B分别不出是否旧的，照样子正常回包。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>中，A检测到 B 返回的ACK不正确，所以返回 RST(reset)</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>中，B接收到  RST(reset)信号，于是变成 LISTEN 状态。</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>中，新连接正常的 SYN终于到达了，三次握手正常进行。</span><br></pre></td></tr></table></figure><p><strong>对上面来个总结：</strong> 首先，如果A要跟B通信，A先向B发送一个序列号 <code>seq</code> 以及 <code>SYN</code> 标志，如果在B收到A的这个<code>seq</code> 之前有别的连接请求到达，比如说B收到了一个旧的的SYN信号以及 <code>seq</code> 序列号,那么此时B是不知道这个请求是A新发出的还是以前的，所以B会正常的往A回复响应，即发一个SYNC 标志与ACK = seq + 1，当A收到这个ACK时发现这个回复与自己当前的Seq不匹配，那么此时A会发送一个RST消息使B进入一个listen状态，只监听A当前发送给B的分组，当A刚刚发送的seq = 100 的分组到达时，B才向A返回确认，当A收到确认之后再往B发送一个确认，当B再次收到A的确认时，双方连接建立。如图<br><img src="/images/2019/03/08/1ff41a20-4149-11e9-a650-ffecf938c9ad.png" alt="image.png"></p><h4 id="下面来聊一聊http请求慢的问题"><a href="#下面来聊一聊http请求慢的问题" class="headerlink" title="下面来聊一聊http请求慢的问题"></a>下面来聊一聊http请求慢的问题</h4><p>请求慢的分析主要有以下几个方面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当一个http请求发出之后会经历以下几个阶段：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.如果不是直接通过IP连接，那么会有DNS寻址过程，这个过程相对耗时</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.TCP三次握手连接建立</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.服务端解析请求，返回结果数据（服务端事务处理）</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.客户端解析返回结果</span><br></pre></td></tr></table></figure><p>那么正对上面的过程会有如下解决方案：</p><p>1.如果在服务器IP地址已知的情况下，使用IP访问，去除DNS寻址的过程</p><p>2.一般来说服务端的事务处理都比较块，真正耗时的地方在于握手建立连接，此时可以使用连接池复用连接</p><p>3.请求体优化，如果请求体过大，那么这个在传输过程中也时比较耗时的</p><p>4.并行的服务端事务处理</p><h3 id="http在Android中的具体实现"><a href="#http在Android中的具体实现" class="headerlink" title="http在Android中的具体实现"></a>http在Android中的具体实现</h3><p>在Android有几个鼎鼎大名的网络请求 框架，一个是 <strong>Volly</strong>，一个是 <strong>Okhttp</strong></p><p>个人对Okhttp相对来说比较熟，在接下来的文章中会有对Okhttp的具体分析</p><p>下面的一篇我们来说说https : <a href="https://brokeno.github.io/2019/03/08/https/" target="_blank" rel="noopener">https 加密解密以及验证与签名</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本文的主要意义在于通过逻辑的分析与概括，弄清楚以下几个问题&quot;&gt;&lt;a href=&quot;#本文的主要意义在于通过逻辑的分析与概括，弄清楚以下几个问题&quot; class=&quot;headerlink&quot; title=&quot;本文的主要意义在于通过逻辑的分析与概括，弄清楚以下几个问题:&quot;&gt;&lt;/a&gt;本文的主要意义在于通过逻辑的分析与概括，弄清楚以下几个问题:&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;http 是什么&lt;/li&gt;
&lt;li&gt;http 的作用是什么&lt;/li&gt;
&lt;li&gt;http 的主要结构是什么&lt;/li&gt;
&lt;li&gt;tcp 的工作机制与原理&lt;/li&gt;
&lt;li&gt;http在Android中的具体实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;首先我们来聊聊http是什么？&quot;&gt;&lt;a href=&quot;#首先我们来聊聊http是什么？&quot; class=&quot;headerlink&quot; title=&quot;首先我们来聊聊http是什么？&quot;&gt;&lt;/a&gt;首先我们来聊聊http是什么？&lt;/h3&gt;&lt;h4 id=&quot;学过计算机的人都知道，http是基于C-S架构的-应用层-网络通信协议&quot;&gt;&lt;a href=&quot;#学过计算机的人都知道，http是基于C-S架构的-应用层-网络通信协议&quot; class=&quot;headerlink&quot; title=&quot;学过计算机的人都知道，http是基于C/S架构的 应用层 网络通信协议&quot;&gt;&lt;/a&gt;学过计算机的人都知道，http是基于C/S架构的 应用层 网络通信协议&lt;/h4&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用github + Hexo搭建自己个人博客的踩坑过程</title>
    <link href="http://yoursite.com/2019/03/07/github-hexo/"/>
    <id>http://yoursite.com/2019/03/07/github-hexo/</id>
    <published>2019-03-07T03:02:47.000Z</published>
    <updated>2019-10-24T06:03:59.538Z</updated>
    
    <content type="html"><![CDATA[<p>其实一直以来都有弄一个自己私人博客的想法，但一直没有付诸行动。其实前段时间也有在简书与掘金写过博客，但是总觉得那些博客弄得花里胡哨，不是自己想要的。最终决定搭建自己的博客系统是在两天前，有一个自己的安心写东西的地方，也好记录自己成长的脚印。</p><p>下面就分享一下自己通过HEXO + github搭建自己个人博客的<strong>踩坑</strong>与折腾过程（后续效果优化会持续更新）<br>搭建环境：windows 10<br><a id="more"></a></p><p>1.首先，我们搭建的基本原则是将个人博客文件上传到github，然后进行访问，所以首先需要注册一个github账号，新建一个repository<br><img src="/images/2019/03/07/5fe5c8f0-408a-11e9-9621-77018395f2ce.png" alt="image.png"></p><p>如果仓库的名字与github不一致，则在设置界面下面的东西需要修改，选择master branch，且访问路径需要带上全程，即”<a href="http://github.com//xxxx.github.io&quot;" target="_blank" rel="noopener">http://github.com//xxxx.github.io&quot;</a></p><p><img src="/images/2019/03/07/c0f6b910-408a-11e9-9621-77018395f2ce.png" alt="image.png"></p><p>2.开始安装所需环境（<strong>git，nodejs</strong>）</p><p>nodejs的下载路径：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Nodejs</a></p><p>git的下载路径：<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">Git for Windows. 这里提供一个国内的下载站，方便网友下载</a></p><p>当git安装完成之后需要配置git的全局用户名与邮箱（这里用户名就是你的github的用户名，邮箱为github注册邮箱）</p><p>打开git bash 输入的命令行为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的github名称&quot;</span><br><span class="line">git config --global user.email &quot;你的github注册邮箱&quot;</span><br></pre></td></tr></table></figure></p><p>如下图所示：<br><img src="/images/2019/03/07/5e52b390-408f-11e9-9621-77018395f2ce.png" alt="image.png"></p><p>3.安装hexo运行环境</p><p>命令行： <strong>npm install -g hexo-cli</strong> （如果找不到npm命令需要去配置环境变量）</p><p>安装时间可能有点长，稍微等待一下</p><p>4.hexo安装完成之后要开始初始化，切换到你博客想要放置的文件夹比方说 F：。然后执行以下指令：<br>hexo init xxxx（文件夹名），执行完成之后文件夹内容会如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019/03/07/14a5b330-4091-11e9-9621-77018395f2ce.png" alt="image.png"></p><p>因为你初始化hexo 之后source目录下自带一篇hello world文章, 所以直接执行下方命令<br>$ <strong>hexo generate</strong><br>启动本地服务器<br>$ <strong>hexo server</strong><br>在浏览器输入 <a href="http://localhost:4000/就可以看见网页和模板了" target="_blank" rel="noopener">http://localhost:4000/就可以看见网页和模板了</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p><p>此时你可以通过<a href="http://localhost:4000/看到你博客的样子了，接下来我们要将它部署到github，然后通过github来访问" target="_blank" rel="noopener">http://localhost:4000/看到你博客的样子了，接下来我们要将它部署到github，然后通过github来访问</a></p><p>5.部署到github，部署到github先要来设置一个ssh key这个key的生成使用以下的指令：</p><p><strong>ssh-keygen -t rsa -C “Github的注册邮箱地址”</strong></p><p>一路Enter过来就可以了，最后会得到信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub.</span><br></pre></td></tr></table></figure></p><p>打开该文件，复制里面的全部内容，打开github的setting然后类似如下操作：</p><p><img src="/images/2019/03/07/aeb6a8c0-4092-11e9-9621-77018395f2ce.png" alt="image.png"><br>title可以随便填写。</p><p>添加这个ssh key的意义在于如果是在别的电脑上想要down你项目的内容是会有重新验证的。</p><p>6.配置博客的信息，打开 <strong>_config.yml</strong> 文件，修改参数信息，里面有很多内容，可以根据自己的需要进行配置，以后有机会再来慢慢研究。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特别提示：特别提醒，在每个参数的：后都要加一个空格</span><br></pre></td></tr></table></figure></p><p>我主要配置了以下几项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">title: 【临江仙（BrokenO)】</span><br><span class="line">subtitle: Stay hungry, Stay foolish</span><br><span class="line">description: Talking is cheap,show me your code </span><br><span class="line">keywords:</span><br><span class="line">author: 【临江仙（BrokenO)】</span><br><span class="line">language: zh-CN #zh-Hans（next主题用到的）</span><br><span class="line">timezone: Asia/Shanghai</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/BrokenO/BrokenO.github.io.git(这个要配置成你自己的)</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>7.发表文章</p><p>命令行： hexo new “崔斯特测试文章”  （这个是新建一篇博客）</p><p>找到该文章，打开，使用Markdown语法，随便编辑几句保存</p><p>然后切换到博客的根目录执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">F:\test\blog</span><br><span class="line">$ hexo clean //先清空本地缓存</span><br><span class="line">INFO  Deleted database.</span><br><span class="line">INFO  Deleted public folder.</span><br><span class="line"></span><br><span class="line">F:\test\blog </span><br><span class="line">$ hexo generate //生成静态文件</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 1.48 s</span><br><span class="line">#省略</span><br><span class="line">INFO  29 files generated in 4.27 s</span><br><span class="line"></span><br><span class="line">F:\test\blog</span><br><span class="line">$ hexo server //启动本地浏览服务器</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p><p>此时博客已经通过<a href="http://localhost:4000/进行预览了" target="_blank" rel="noopener">http://localhost:4000/进行预览了</a></p><p>8.发布到网上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F:\test\blog</span><br><span class="line">$ hexo deploy //发布到网上</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">#省略</span><br></pre></td></tr></table></figure><h4 id="下面来说一下数据迁移的方式"><a href="#下面来说一下数据迁移的方式" class="headerlink" title="下面来说一下数据迁移的方式"></a>下面来说一下数据迁移的方式</h4><p>具体的迁移方式详见：<a href="https://blog.csdn.net/White_Idiot/article/details/80685990" target="_blank" rel="noopener">创建Git分支将Hexo博客迁移到其它电脑</a></p><h4 id="最后来说说git提交的三部曲"><a href="#最后来说说git提交的三部曲" class="headerlink" title="最后来说说git提交的三部曲"></a>最后来说说git提交的三部曲</h4><ol><li>本地发生改变之后，利用 <strong><code>git status</code></strong> 查看当前的改变情况</li><li>利用 <strong><code>git add .</code></strong> 将当前的改变添加到缓存区</li><li>指令 <strong><code>git commit -m &quot;注释&quot;</code></strong> 提交文件</li><li><strong><code>git push origin xxxx(分支名)</code></strong> 更新到分支</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实一直以来都有弄一个自己私人博客的想法，但一直没有付诸行动。其实前段时间也有在简书与掘金写过博客，但是总觉得那些博客弄得花里胡哨，不是自己想要的。最终决定搭建自己的博客系统是在两天前，有一个自己的安心写东西的地方，也好记录自己成长的脚印。&lt;/p&gt;
&lt;p&gt;下面就分享一下自己通过HEXO + github搭建自己个人博客的&lt;strong&gt;踩坑&lt;/strong&gt;与折腾过程（后续效果优化会持续更新）&lt;br&gt;搭建环境：windows 10&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
</feed>
